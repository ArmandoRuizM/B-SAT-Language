#lang eopl

; Proyecto de Fundamentos de Lenguajes de Programacion:
; Profesor Robinson Duque.
; Integrantes del equipo:
; -Cristian Alexis Alegria Carreño - 1813013
; -Katerine Rodriguez Castaño      - 1810238
; -Armando Ruiz Mendez             - 1872076
; 
; Lenguaje de programación B-SAT
; 


;******************************************************************************************
;;;;; B-SAT
;;La cerradura positiva es representada por + y la cerradura de Kleene por *
;; La definición BNF para las expresiones del lenguaje:
;;
;;  <program>       ::= <expression>
;;                      <a-program (exp)>

;;  <expression>    ::= <numero>
;;                      <numero (datum)>
;;                  ::= <identificador>
;;                      <identificador (id)>
;;                  ::= (x16 numero+)
;;                      <hexadecimal (datum datums)>
;;                  ::= '<identificador>'
;;                      <caracter (char)>
;;                  ::= "<identificador>"
;;                      <cadena (str)>

;;                  ::= var {<identificador> = <expression>}*(,) in <expression>
;;                      <var-def (ids rands body)>
;;                  ::= cons {<identificador> = <expression>}*(,) in <expression>
;;                      <cons-def (ids rands body)>
;;                  ::= rec {<identificador> {identificador}*(;) = <expression>}*(,) in <expression>
;;                      <rec-def (proc-names ids bodies bodyrec)>

;;                  ::= <arit-prim-bin>(<numero>, <numero>)
;;                      <primapp-num-bin (prim rand1 rand2)>
;;                  ::= <arit-prim-un>(<numero>)
;;                      <primapp-num-un (prim rand)>

;;                  ::= <hexa-prim-bin>(<expression>, <expression>)
;;                      <primapp-hex-bin (prim hex1 hex2)>
;;                  ::= <hexa-prim-un> (<expression>)
;;                      <primapp-hex-un (prim hex)>

;;                  ::= <cad-prim-bin> (<expression> <expression>+)
;;                      <primapp-cad-bin (prim cad1 cad2 cads)>
;;                  ::= <cad-prim-un> (<expression>)
;;                      <primapp-cad-un (prim cad)>

;;                  ::= {<expression>}*(,)
;;                      <lista (elements)>
;;                  ::= (vacio)
;;                      <lista-vacia>
;;                  ::= <list-prim-un> (<expression>)
;;                      <primapp-list-un (prim list)>
;;                  ::= <list-prim-gen> (<expression>)*
;;                      <primapp-list-gen (prim args)>
;;                  ::= <list-prim-ret> (<expression>)
;;                      <primapp-list-ret (prim list)>

;;                  ::= vector[<expression>]*(;)
;;                      <vector (elements)>
;;                  ::= <vector-prim-un> (<expression>)
;;                      <primapp-vector-un (prim vector)>
;;                  ::= <vector-prim-gen> (<expression>)*
;;                      <primapp-vector-gen (prim args)>
;;                  ::= <vector-prim-ref> (<numero> from <expression>)
;;                      <primapp-vector-ref (prim ref vector)>
;;                  ::= <vector-prim-set> (<numero> to <expression> from <expression>)
;;                      <primapp-vector-set (prim ref value vector)>

;;                  ::= registro {<identificador> = <expression>}+(;)
;;                      <registro (id value ids values)>
;;                  ::= <registro-prim-un> (<expression>)
;;                      <primapp-registro-un (prim registro)>
;;                  ::= <registro-prim-gen> (<identificador> = <expression>)*(,)
;;                      <primapp-registro-gen (prim id value ids values)>
;;                  ::= <registro-prim-ref> (<identificador> from <expression>)
;;                      <primapp-registro-ref (prim id registro)>
;;                  ::= <registro-prim-set> (<identificador> to <expression> from <expression>)
;;                      <primapp-registro-set (prim id valor registro)>

;;                  ::= <exp-bool>
;;                      <expresion-booleana (exp)>

;;                  ::= begin {<expression>}+(;) end
;;                      <begin-exp (exp exps)>
;;                  ::= if <exp-bool> then <expression> [else <expression>] end
;;                      <if-exp (cond posit negat)>
;;                  ::= while <exp-bool> do (<expression>) done
;;                      <while-exp (cond body)>
;;                  ::= for <identificador> = <expression> <for-prim> <expression> do (<expression>) done
;;                      <for-exp (id init prim cap body)>

;;                  ::= set <identificador> -> <expression>
;;                      <set-exp (id value)>

;;                  ::= print (<expression>)
;;                      <print-exp (exp)>

;;                  ::= FNC <numero> (<clausula-or>)+(and)
;;                      <FNC-exp (nVars clause clauses)>

;;                  ::= proc({<identificador>}*) <expression>
;;                      <proc-exp (ids body)>

;;                  ::= procrec{<identificador> {identificador}*(;) = <expression>}* in <expression>
;;                      <procrec-exp (proc-names ids body body-procrec)>

;;                  ::= (<expression> {<expression>}*)
;;                      <app-exp proc rands>

;; <clausula-or>    ::= (<numero>)+(or)
;;                      <or-clause (arg args)>

;;  <exp-bool>      ::= <pred-prim> (<expression>, <expression>)
;;                      <exp-bool-pred (prim exp1 exp2)>
;;                  ::= <oper-bin-bool> (<exp-bool>, <exp-bool>)
;;                      <exp-bool-bin (prim exp1 exp2)>
;;                  ::= <bool>
;;                      <booleano-simple (bool)>
;;                  ::= <oper-un-bool> (<exp-bool>)
;;                      <exp-bool-un (prim exp)>

;;  <bool>          ::= true | false

;;  <list-prim-un>  ::= vacio? | lista?
;;  <list-prim-gen> ::= crear-lista | append
;;  <list-prim-ret> ::= cabeza | cola

;; <vector-prim-un> ::= vector?
;;<vector-prim-gen> ::= crear-vector
;;<vector-prim-ref> ::= ref-vector
;;<vector-prim-set> ::= set-vector

;;<registro-prim-un>::= registro?
;<registro-prim-gen>::= crear-registro
;<registro-prim-ref>::= ref-registro
;<registro-prim-set>::= set-registro

;;  <for-prim>      ::= to | downto

;;  <proc-prim>      ::= , | ,&

;;  <pred-prim>     ::= < | > | <= | >= | == | <>

;;  <oper-bin-bool> ::= or | and

;;  <oper-un-bool>  ::= not

;; <arit-prim-bin>  ::= + | - | * | / | %

;;  <arit-prim-un>  ::= add1 | sub1

;; <hexa-prim-bin>  ::= h.+ | h.- | h.*

;;  <hexa-prim-un>  ::= h.add1 | h.sub1

;;  <cad-prim-un>   ::= lenght

;;  <cad-prim-bin>  ::= concat

;******************************************************************************************

;Especificación Léxica

(define scanner-spec-simple-interpreter
'((espacio-en-blanco (whitespace) skip);;ignorar espacios en blanco. skip: escape
  (comentario
   ("%" (arbno (not #\newline))) skip);;arbno:Cerradura de  Kleene, puede o no puede haber elementos, si hay una nueva linea escape(skip)
  (identificador (letter (arbno (or letter digit))) symbol)
  (numero   
   (digit (arbno digit)) number);;(arbno digit) me garantiza que haya al menos un digito, es decir arbno se convierte en una ceradura positiva(+) 
  (numero
   ("-" digit (arbno digit)) number)
  (numero
   (digit (arbno digit) "." digit (arbno digit)) number)
  (numero
   ("-" digit (arbno digit) "." digit (arbno digit)) number)))


;Especificación Sintáctica (gramática)

(define grammar-simple-interpreter
  ;;Todo lo que se escriba en el lenguaje, sera un programa
  '((program (expression) a-program)
    ;;DATOS:
    (expression (identificador) identificador)
    (expression (numero) numero)
    (expression ("(" "x16"  (arbno numero) ")") hexadecimal)
    (expression ("'" identificador "'") caracter)
    (expression ("\"" identificador "\"") cadena)
    (expression ("true") bool-true)
    (expression ("false") bool-false)
    ;;DEFINICIONES:
    (expression ("var" "{" (separated-list identificador "=" expression ",") "}" "in" expression ) var-def)
    (expression ("cons" "{" (separated-list identificador "=" expression ",") "}" "in" expression) cons-def)
    (expression ("rec" "{" (separated-list identificador "{" (separated-list identificador ";") "}" "=" expression ",") "}" "in" expression) rec-def)

    ;;APLICACIONES DE PRIMITIVAS:
    ;;SOBRE NUMEROS ENTEROS Y FLOATING:
    (expression (arit-prim-bin "(" expression "," expression ")") primapp-num-bin)
    (expression (arit-prim-un "(" expression ")") primapp-num-un)

    ;;SOBRE NUMEROS HEXADECIMALES:
    (expression (hexa-prim-bin "(" expression "," expression")") primapp-hex-bin)
    (expression (hexa-prim-un "(" expression ")") primapp-hex-un)
    ;;SOBRE CADENAS:
    (expression (cad-prim-bin "(" expression expression (arbno expression)")") primapp-cad-bin)
    (expression (cad-prim-un "(" expression ")") primapp-cad-un)
    
    ;;DATOS PREDEFINIDOS:
    ;;LISTAS:
    (expression ("{" (separated-list expression ";") "}") lista)
    ;;EXPRESIONES SOBRE LISTAS:
    (expression (list-prim-un "(" expression ")") primapp-list-un)
    (expression ("(vacio)") lista-vacia)
    (expression (list-prim-gen "(" (separated-list expression ",") ")") primapp-list-gen)
    (expression (list-prim-ret "(" expression ")") primapp-list-ret)
    ;;PRIMITIVAS SOBRE LISTAS:
    ;;PRIMITIVAS UNARIAS:
    (list-prim-un ("vacio?") es-vacio?)
    (list-prim-un ("lista?") es-lista?)
    ;;PRIMITIVAS GENERADORAS:
    (list-prim-gen ("crear-lista") crear-lista)
    (list-prim-gen ("append") juntar-lista)
    ;;PRIMITIVAS QUE RETORNAN:
    (list-prim-ret ("cabeza") ret-cabeza)
    (list-prim-ret ("cola") ret-cola)

     ;;DATOS PREDEFINIDOS:
    ;;VECTORES:  
    (expression ("vector" "[" (separated-list expression ";") "]") vector)
    ;;EXPRESIONES SOBRE VECTORES:
    (expression (vector-prim-un "(" expression ")") primapp-vector-un)
    (expression (vector-prim-gen "(" (separated-list expression ",") ")") primapp-vector-gen)
    (expression (vector-prim-ref "(" numero "from" expression ")") primapp-vector-ref)
    (expression (vector-prim-set "(" numero "to" expression "from" expression ")") primapp-vector-set)
    ;;PRIMITIVAS UNARIAS:
    (vector-prim-un ("vector?") es-vector?)
    
    ;;PRIMITIVAS GENERADORAS:
    (vector-prim-gen ("crear-vector") crear-vector)    
    ;;PRIMITIVAS ...:
    (vector-prim-ref ("ref-vector") ref-vector)    
    (vector-prim-set ("set-vector") set-vector)    

    ;;DATOS PREDEFINIDOS:
    ;;REGISTROS:  
    (expression ("registro" "{" identificador "=" expression (arbno ";" identificador "=" expression) "}") registro)
    ;;EXPRESIONES SOBRE REGISTROS:
    (expression (registro-prim-un "(" expression ")") primapp-registro-un)
    (expression (registro-prim-gen "(" identificador "=" expression (arbno "," identificador "=" expression) ")") primapp-registro-gen)
    (expression (registro-prim-ref "(" identificador "from" expression ")") primapp-registro-ref)
    (expression (registro-prim-set "(" identificador "to" expression "from" expression")") primapp-registro-set)
    ;;PRIMITIVAS UNARIAS:
    (registro-prim-un ("registro?") es-registro?)
    
    ;;PRIMITIVAS GENERADORAS:
    (registro-prim-gen ("crear-registro") crear-registro)    
    ;;PRIMITIVAS ...:
    (registro-prim-ref ("ref-registro") ref-registro)    
    (registro-prim-set ("set-registro") set-registro) 
    
    ;;EXPRESIONES BOOLEANAS:
    (expression (exp-bool) expresion-booleana)
    (exp-bool (pred-prim "(" expression "," expression ")") exp-bool-pred)
    (exp-bool (oper-bin-bool "("expression "," expression ")") exp-bool-bin)
    (exp-bool (oper-un-bool "(" expression ")") exp-bool-un)
    
    ;;ESTRUCTURAS DE CONTROL
    (expression ("begin" "{"expression (arbno ";" expression )"}" "end") begin-exp)
    (expression ("if" expression "then" expression "[" "else" expression "]" "end") if-exp)
    (expression ("while" expression "do" "(" expression ")" "done") while-exp)
    (expression ("for" identificador "=" expression  for-prim expression "do" "(" expression ")" "done") for-exp)

    ;;VARIABLES MUTABLES:
    (expression ("set" identificador "->" expression) set-exp)

    ;;ITERACIÓN
    (expression ("print" "(" expression ")") print-exp)
    (expression ("println" "(" expression ")") println-exp)


    ;;SOPROTE PARA INSTANCIAS SAT:
    (expression ("FNC" numero "(" clausula-or (arbno "and" clausula-or) ")") FNC-exp)
    (clausula-or ("(" numero (arbno "or" numero) ")") or-clause)

    ;;PROCEDIMIENTOS
    (expression ("proc" "(" (arbno identificador)")" "{" expression "}") proc-exp)   
                
    ;;INVOCACION PROCEDIMIENTOS
    (expression ("[" expression (arbno proc-prim) "]") app-exp)
    
    ;;AUXILIARES DE FOR:
    (for-prim ("to") for++)
    (for-prim ("downto") for--)
    
    ;;PASO DE PARAMETROS
    (proc-prim ("," expression) valor)
    (proc-prim (", &" expression) referencia)
    
    ;;OPERADORES BOOLEANOS:
    ;;OPERADORES PREDICADOS:
    (pred-prim ("<") menor)
    (pred-prim (">") mayor)
    (pred-prim ("<=") menor-igual)
    (pred-prim (">=") mayor-igual)
    (pred-prim ("==") equivalente)
    (pred-prim ("<>") diferente)
    ;;OPERADORES BINARIOS:
    (oper-bin-bool ("and") conjuncion)
    (oper-bin-bool ("or") disyuncion)
    ;;OPERADOR UNARIO:
    (oper-un-bool ("not") negacion)

    ;;PRIMITIVAS ARITMETICAS:
    
    (arit-prim-bin ("+") suma-arit)
    (arit-prim-bin ("-") resta-arit)
    (arit-prim-bin ("*") multi-arit)
    (arit-prim-bin ("/") div-arit)
    (arit-prim-bin ("%") modulo-arit)
    (arit-prim-un ("add1") incr-arit)
    (arit-prim-un ("sub1") decr-arit)

    ;;PRIMITIVAS HEXADECIMALES:

    (hexa-prim-bin ("h.+") suma-hexa)
    (hexa-prim-bin ("h.-") resta-hexa)
    (hexa-prim-bin ("h.*") multi-hexa)
    (hexa-prim-un ("h.add1") incr-hexa)
    (hexa-prim-un ("h.sub1") decr-hexa)
    
    ;;PRIMITIVAS SOBRE CADENAS:
    (cad-prim-un ("length") longitud)
    (cad-prim-bin ("concat") concatenar))

  )

;Construidos automáticamente:

(sllgen:make-define-datatypes scanner-spec-simple-interpreter grammar-simple-interpreter)

(define show-the-datatypes
  (lambda () (sllgen:list-define-datatypes scanner-spec-simple-interpreter grammar-simple-interpreter)))

;*******************************************************************************************
;Parser, Scanner, Interfaz

;El FrontEnd (Análisis léxico (scanner) y sintáctico (parser) integrados)

(define scan&parse
  (sllgen:make-string-parser scanner-spec-simple-interpreter grammar-simple-interpreter))

;El Analizador Léxico (Scanner)

(define just-scan
  (sllgen:make-string-scanner scanner-spec-simple-interpreter grammar-simple-interpreter))


;El Interpretador (FrontEnd + Evaluación + señal para lectura )

(define interpretador
  (sllgen:make-rep-loop "--> "
    (lambda (pgm) (eval-program  pgm))
    (sllgen:make-stream-parser 
      scanner-spec-simple-interpreter
      grammar-simple-interpreter)))

;*******************************************************************************************
;El Interprete

;eval-program: <programa> -> numero
; función que evalúa un programa teniendo en cuenta un ambiente dado (se inicializa dentro del programa)

(define eval-program
  (lambda (pgm)
    (cases program pgm
      (a-program (body)
                 (eval-expression body (init-env))))))

; Ambiente inicial
(define init-env
  (lambda ()
    (extend-env
     '(i v x)
     '(1 5 10)
     (empty-env))))

;eval-expression: <expression> <enviroment> -> numero
; evalua la expresión en el ambiente de entrada
(define eval-expression
  (lambda (exp env)
   (cases expression exp
     (identificador (id) (apply-env env id))
     (caracter (char) char)
     (numero (numero) numero)       
     (cadena (str) (symbol->string str))
     (hexadecimal (hexadecimal) hexadecimal)
     (bool-true () #true)
     (bool-false () #false)
     (primapp-cad-bin (prim cad1 cad2 cads) (apply-prim-cad-bin prim (fusionar-listas cad1 cad2 cads env)))
     (primapp-cad-un (prim cad) (apply-prim-cad-un prim (eval-rand cad env)))
     (primapp-num-bin (prim rand1 rand2)
                      (apply-prim-num prim (eval-expression rand1 env) (eval-expression rand2 env)))
     (primapp-num-un (unprim rand)
                     (apply-prim-num-un unprim (eval-expression rand env)))
     (expresion-booleana (exp-bool) (evaluar-exp-bool exp-bool env))
     (var-def (ids rands body) (let ((args (eval-rands rands env)))
                                 (eval-expression body
                                                  (extend-env ids args env))))
     (if-exp (cond posit negat) (if(boolean? (eval-expression cond env))
                                   (if(eval-expression cond env) (eval-expression posit env) (eval-expression negat env))
                                   (eopl:error "Error, la funcion if esperaba un booleano como condicion")))
     (begin-exp (exp exps) 
                (let loop ((acc (eval-expression exp env))
                           (exps exps))
                  (if (null? exps) 
                      acc
                      (loop (eval-expression (car exps) 
                                             env)
                            (cdr exps)))))
     (while-exp (cond body) (if(boolean? (eval-expression cond env))
                               (eval-expression body env) (eopl:error "Error, la funcion while esperaba un booleano como condicion")))
     (for-exp (id init prim cap body) (if (and (number? (eval-expression init env)) (number? (eval-expression cap env)))
                                               (ciclo-for id prim (eval-expression cap env) body (extend-env (list id) (list (eval-expression init env)) env))
                                          (eopl:error "Error, revise los valores tope e inicial del ciclo for, deben ser numeros")))
     (print-exp (exp) (display (eval-expression exp env)))
     (println-exp (exp) (begin
                          (display (eval-expression exp env))
                          (display "\n")))
     (default (eopl:error "Error, expresion no implementada aun.\nEstamos trabajando en ello! :)")))))

;*****************************************************************************************
; funciones auxiliares para aplicar eval-expression a cada elemento de una 
; lista de operandos (expresiones)
(define eval-rands
  (lambda (rands env)
    (map (lambda (x) (eval-rand x env)) rands)))

(define eval-rand
  (lambda (rand env)
    (eval-expression rand env)))

(define fusionar-listas
  (lambda (l1 l2 ls env)
    (cond [(null? (eval-rands ls env)) (list (eval-rand l1 env) (eval-rand l2 env))]
          [else (append (list (eval-rand l1 env) (eval-rand l2 env)) (eval-rands ls env))])))


;******************************************************************************************
;Funciones auxiliares para booleanos:

(define evaluar-exp-bool
  (lambda (exp env)
    (cases exp-bool exp
      (exp-bool-pred (prim exp1 exp2) (apply-prim-bool-pred prim (eval-expression exp1 env) (eval-expression exp2 env)))
      (exp-bool-bin (prim exp1 exp2) (apply-prim-bool-bin prim (eval-expression exp1 env) (eval-expression exp2 env)))
      (exp-bool-un (prim exp) (apply-prim-bool-un prim (eval-expression exp env))))))

(define apply-prim-bool-pred
  (lambda (prim exp1 exp2)
    (cases pred-prim prim
      (menor () (if(and(number? exp1) (number? exp2))(< exp1 exp2)(eopl:error "Error, la funcion menor esperaba un numero")))
      (mayor () (if(and(number? exp1) (number? exp2))(> exp1 exp2)(eopl:error "Error, la funcion mayor esperaba un numero")))
      (menor-igual () (if(and(number? exp1) (number? exp2))(<= exp1 exp2)(eopl:error "Error, la funcion menor-igual esperaba un numero")))
      (mayor-igual () (if(and(number? exp1) (number? exp2))(>= exp1 exp2)(eopl:error "Error, la funcion mayor-igual esperaba un numero")))
      (equivalente () (if(and(number? exp1) (number? exp2))(= exp1 exp2)(eopl:error "Error, la funcion equivalente esperaba un numero")))
      (diferente () (if(and(number? exp1) (number? exp2))(not (= exp1 exp2))(eopl:error "Error, la funcion negacion esperaba un numero"))))))

(define apply-prim-bool-bin
  (lambda (prim exp1 exp2)
    (cases oper-bin-bool prim
      (conjuncion () (if(and (boolean? exp1) (boolean? exp2))(and exp1 exp2)(eopl:error "Error, la funcion  conjuncion esperaba un booleano")))
      (disyuncion () (if(and (boolean? exp1) (boolean? exp2))(or exp1 exp2)(eopl:error "Error, la funcion  disyuncion esperaba un booleano"))))))

(define apply-prim-bool-un
  (lambda (prim exp)
    (cases oper-un-bool prim
      (negacion () (not exp)))))


;******************************************************************************************
;Funciones auxiliares para cadenas:

(define apply-prim-cad-bin
  (lambda (prim cads)
    (cases cad-prim-bin prim
      (concatenar () (concatenar-cadenas cads)))))

(define concatenar-cadenas
  (lambda (cads)
    (cond [(null? cads) ""]
          [(string? (car cads)) (string-append (car cads) (concatenar-cadenas (cdr cads)))]
          [else (eopl:error "Error, la funcion concatenar solo funciona con cadenas")])))

(define apply-prim-cad-un
  (lambda (prim cad)
    (cases cad-prim-un prim
      (longitud () (if (string? cad) (string-length cad) (eopl:error "Error, la funcion longitud esperaba una cadena"))))))

;******************************************************************************************
;Funciones auxiliares para estructuras de control:

(define ciclo-for
  (lambda (id prim tope body env)
    (cases for-prim prim
      (for++ () (ciclo-for++ id tope body env))
      (for-- () (ciclo-for-- id tope body env)))))

(define ciclo-for++
  (lambda (id cap body env)
    (letrec (
             (iterar
          (lambda (id cap body env)
            (cond [(>= (apply-env env id) cap) "end"]
                  [else (begin
                          (eval-expression body env)
                          (iterar id cap body (extend-env (list id) (list (+ (apply-env env id) 1)) env))
                          )]
                  ))))
      (iterar id cap body env))
    ))

(define ciclo-for--
  (lambda (id cap body env)
    (letrec (
             (iterar
          (lambda (id cap body env)
            (cond [(<= (apply-env env id) cap) "end"]
                  [else (begin
                          (eval-expression body env)
                          (iterar id cap body (extend-env (list id) (list (- (apply-env env id) 1)) env))
                          )]
                  ))))
      (iterar id cap body env))
    ))
;*******************************************************************************************
;Funciones primitivas numeros
(define apply-prim-num
  (lambda (prim rand1 rand2)
    (cases arit-prim-bin prim
      (suma-arit () (if (or (null? rand1) (null? rand2))
                       (eopl:error 'apply-prim-num
                                   "Error, la funcion suma espera dos operandos")
                       (+ rand1 rand2)))
      (resta-arit () (if (or (null? rand1) (null? rand2))
                             (eopl:error 'apply-prim-num
                                         "Error, la funcion resta espera dos operandos")
                             (- rand1 rand2)))
      (multi-arit () (if (or (null? rand1) (null? rand2))
                        (eopl:error 'apply-prim-num
                                    "Error, la funcion multiplicacion espera dos operandos")
                        (* rand1 rand2)))
      (div-arit () (if (or (null? rand1) (null? rand2))
                       (eopl:error 'apply-prim-num
                                   "Error, la funcion division espera dos operandos")
                       (/ rand1 rand2)))
      (modulo-arit () (if (or (null? rand1) (null? rand2))
                       (eopl:error 'apply-prim-num
                                   "Error, la funcion modulo espera dos operandos")
                       (remainder rand1 rand2)))
      )))

(define apply-prim-num-un
  (lambda (unprim rand)
    (cases arit-prim-un unprim
      (incr-arit () (if (eqv? '() rand)
                        (eopl:error 'apply-prim-num-un
                                    "Error, la funcion incremento espera un numero")
                        (+ rand 1)))
      (decr-arit () (if (eqv? '() rand)
                        (eopl:error 'apply-prim-num-un
                                    "Error, la funcion decremento espera un numero")
                        (- rand 1))))))
;******************************************************************************************
;Ambientes

;definición del tipo de dato ambiente
(define-datatype environment environment?
  (empty-env-record)
  (extended-env-record (syms (list-of symbol?))
                       (vals (list-of scheme-value?))
                       (env environment?)))

(define scheme-value? (lambda (v) #t))

;empty-env:      -> enviroment
;función que crea un ambiente vacío
(define empty-env  
  (lambda ()
    (empty-env-record)))       ;llamado al constructor de ambiente vacío 


;extend-env: <list-of symbols> <list-of numbers> enviroment -> enviroment
;función que crea un ambiente extendido
(define extend-env
  (lambda (syms vals env)
    (extended-env-record syms vals env))) 

;función que busca un símbolo en un ambiente
(define apply-env
  (lambda (env sym)
    (cases environment env
      (empty-env-record ()
                        (eopl:error 'apply-env "No binding for ~s" sym))
      (extended-env-record (syms vals env)
                           (let ((pos (list-find-position sym syms)))
                             (if (number? pos)
                                 (list-ref vals pos)
                                 (apply-env env sym)))))))


;****************************************************************************************
;Funciones Auxiliares

; funciones auxiliares para encontrar la posición de un símbolo
; en la lista de símbolos de unambiente

(define list-find-position
  (lambda (sym los)
    (list-index (lambda (sym1) (eqv? sym1 sym)) los)))

(define list-index
  (lambda (pred ls)
    (cond
      ((null? ls) #f)
      ((pred (car ls)) 0)
      (else (let ((list-index-r (list-index pred (cdr ls))))
              (if (number? list-index-r)
                (+ list-index-r 1)
                #f))))))


(interpretador)
; EJEMPLOS:
; PROGRAMA:
; a-program: Todo lo que se ejecute en B-SAT, es un programa, que a su vez es una expresion.
; (scan&parse "0")
; *******************************************************************************************************
; DATOS:
; identificador: Es una expresion y es el nombre que se le asocia a un dato, debe empezar por una letra y
; puede contener letras y numeros sin espacios.
; (scan&parse "id1")
; -------------------------------------------------------------------------------------------------------
; numero: Es una expresion y representa un numero.
; (scan&parse "20")
; (scan&parse "-20")
; (scan&parse "20.1")
; (scan&parse "-20.1")
; -------------------------------------------------------------------------------------------------------
; hexadecimal: Es una expresion y representa un numero hexadecimal, tiene la forma:
; (x16 num0 num1 num2...)
; (scan&parse "(x16 4 1 0 7 14)")
; -------------------------------------------------------------------------------------------------------
; caracter: Es una expresion y representa una sola letra de la forma 'identificador'.
; (scan&parse "'A'")
; -------------------------------------------------------------------------------------------------------
; cadena: Es una expresion y representa una cadena de texto que debe empezar con una letra, seguida
; de letras o numeros y sin espacios, de la forma: "EstoEsUnaCadena"
; (scan&parse "\"EjemploDeCadena\"")
; -------------------------------------------------------------------------------------------------------
; bool: Los Booleanos se implementan luego como parte de las expresiones booleanas
; *******************************************************************************************************
; DEFINICIONES:
; var-def: Es una expresion que permite definir variables mutables y asignarles valores iniciales
; y finalmente, ejecuta una expresion, es de la forma: var{id=exp, id1=exp1...} in exp2
; (scan&parse "var{x=0,y=1} in y")
; -------------------------------------------------------------------------------------------------------
; cons-def: Es una expresion que permite asociar constantes a identificadores y finalmente, ejecuta
; una expresión, es de la forma: cons{id=exp, id1=exp1} in exp2
; (scan&parse "cons{x=0,y=1} in y")
; -------------------------------------------------------------------------------------------------------
; rec-def: Es una expresion que permite asociar procedimientos recursivos a identificadores y finalmente
; ejecuta una expresion, es de la forma: rec{id0{id1;id2...}=exp0, id3{id4;id4...}=exp1} in exp2
; (scan&parse "rec{A{x;y;z} = 5} in A")
; (scan&parse "rec{A{x;y;z} = 5, B{m;n;o} = -5} in B")
; *******************************************************************************************************
; APLICACIONES DE PRIMITIVAS:
; -Sobre enteros y floating:
; °primapp-num-bin: Es una expresion que representa una operacion binaria con numeros enteros o flotantes,
; las primitivas binarias son: +, -, *, /, %. Se aplican de la forma: prim(num1, num2)
; (scan&parse "-(4, 2)")
; (scan&parse "+(4, 2)")
; (scan&parse "*(4, 2)")
; °primapp-num-un: Es una expresion que representa una operacion unaria con numeros enteros o flotantes,
; las primitivas unarias son: add1, sub1. Se aplican de la forma: prim(num1)
; (scan&parse "add1(10)")
; (scan&parse "sub1(10)")
; -Sobre numeros hexadecimales:
; °primapp-hex-bin: Es una expresion que representa una operacion binaria con numeros hexadecimales,
; las primitivas binarias son: h.+, h.-, h.*. Se aplican de la forma: prim(exp1, exp2)
; (scan&parse "h.+((x16 0 1), (x16 3 5 0))")
; (scan&parse "h.-((x16 0 1), (x16 3 5 0))")
; (scan&parse "h.*((x16 0 1), (x16 3 5 0))")
; °primapp-hex-un: Es una expresion que representa una operacion unaria con numeros hexadecimales,
; las primitivas unarias son: h.add1, h.sub1. Se aplican de la forma: prim(exp1)
; (scan&parse "h.add1((x16 0 1))")
; (scan&parse "h.sub1((x16 0 1))")
; -Sobre cadenas:
; °primapp-cad-bin: Es una expresion que representa una operacion de dos o mas cadenas,
; usando la primitiva concat. Tiene la forma: prim(exp1 exp2...)
; (scan&parse "concat(\"Hola\" \"Mucho\" \"Gusto\")")
; °primapp-cad-un: Es una expresion que representa una operacion con una cadena, usando la primitiva
; lenght. Tiene la forma: prim(exp1)
; (scan&parse "lenght(\"Hola\")")
; *******************************************************************************************************
; DATOS PREDEFINIDOS:
; lista: Es una expresion que reune otras expresiones no mutables separados por punto y coma, encerrados
; entre llaves.
; (scan&parse "{a; 1; b; 2; c; 3}")
; EXPRESIONES SOBRE LISTAS:
; UNARIAS: son representadas por primapp-list-un
; -es-vacio?: Es una expresion que determina si una expresion es una lista vacia, tiene la forma:
; vacio?(exp)
; (scan&parse "vacio?({})")
; -es-lista?: Es una expresion que determina si una expresion es una lista valida, tiene la forma:
; lista?(exp)
; (scan&parse "lista?({1; 2; 3})")
; GENERADORAS: son representadas por primapp-list-gen
; -crear-lista: Es una expresion que crea una lista con las expresiones dadas, tiene la forma:
; crear-lista(exp1 exp2...)
; (scan&parse "crear-lista(1 2 3 4 5)")
; -juntar-lista: Es una expresion que une listas, en una sola, tiene la forma:
; append({exp1} {exp2; exp3}...)
; (scan&parse "append({1} {2; 3})")
; QUE RETORNAN: son representadas por primapp-list-ret
; -ret-cabeza: Es una expresion que retorna el primer elemento de una lista, tiene la forma:
; cabeza({exp1; exp2...})
; (scan&parse "cabeza({2; 3})")
; -ret-cola: Es una expresion que retorna el resto de elementos de una lista, después del primero,
; tiene la forma: cola({exp1; exp2 ...})
; (scan&parse "cola({2; 3})")
; GENERAR VACIO:
; -lista-vacia: Es una expresion que representa una lista vacia, tiene la forma: (vacio)
; (scan&parse "(vacio)")
; -------------------------------------------------------------------------------------------------------
; vector:DATOS PREDEFINIDOS:
; vector: Es una expresion que reune otras expresiones no mutables separados por punto y coma, encerrados
; entre corchetes.
; (scan&parse "vector[a; 1; b; 2; c; 3]")
; EXPRESIONES SOBRE VECTORES:
; UNARIAS: son representadas por primapp-vector-un
; -es-vector?: Es una expresion que determina si una expresion es un vector valido, tiene la forma:
; vector?(exp)
; (scan&parse "vector?(vector[1; 2; 3])")
; GENERADORAS: son representadas por primapp-vector-gen
; -crear-vector: Es una expresion que crea un vector con las expresiones dadas, tiene la forma:
; crear-vector(exp1 exp2...)
; (scan&parse "crear-vector(1, 2, 3, 4, 5)")
; QUE RETORNA: es representada por primapp-vector-ref
; -ref-vector: Es una expresion que retorna el valor de un vector en la referencia indicada, tiene la forma:
; ref-vector(num1 from exp1)
; (scan&parse "ref-vector(0 from vector[1;2;3;4])")
; QUE MODIFICA: es representada por primapp-vector-set
; -set-vector: Es una expresion que modifica el valor de un vector en la referencia indicada, tiene la forma:
; set-vector(num1 to exp1 from exp2)
; (scan&parse "set-vector(0 to -2 from vector[2; 3])")
; 
; -------------------------------------------------------------------------------------------------------
; registro:
; registro:DATOS PREDEFINIDOS:
; registro: Es una expresion que reune otras expresiones no mutables separados por punto y coma, encerrados
; entre llaves.
; (scan&parse "registro{x=2;Y=3;Z=4}")
; EXPRESIONES SOBRE REGISTROS:
; UNARIAS: son representadas por primapp-registro-un
; -es-registro?: Es una expresion que determina si una expresion es un registro valido, tiene la forma:
; registro?(exp)
; (scan&parse "registro?(registro{x=2;Y=3;Z=4})")
; GENERADORAS: son representadas por primapp-registro-gen
; -crear-registro: Es una expresion que crea un registro con las expresiones dadas, tiene la forma:
; crear-registro(exp1 exp2...)
; (scan&parse "crear-registro(a=1, b=2, c=3)")
; QUE RETORNA: es representada por primapp-registro-ref
; -ref-registro: Es una expresion que retorna el valor que le corresponde a un identificador en el registro,
; tiene la forma: ref-registro(id0 from exp0)
; (scan&parse "ref-registro(x from registro{x=2;Y=3;Z=4})")
; QUE MODIFICA: es representada por primapp-registro-set
; -set-registro: Es una expresion que modifica el valor que le corresponde a un identificador en el registro,
; tiene la forma: set-registro(id0 to exp0 from exp1)
; (scan&parse "set-registro(x to -2 from registro{x=2;Y=3;Z=4})")
; -------------------------------------------------------------------------------------------------------
; expresion-booleana: Es una expresion que esta conformada por una exp-bool.
; OPERACIONES PREDICADO: son representadas por exp-bool-pref
; -menor: Es una expresion que determina si un numero es menor que otro, tiene la forma:
; <(exp1, exp2)
; (scan&parse "<(1, 2)")
; -mayor: Es una expresion que determina si un numero es mayor que otro, tiene la forma:
; >(exp1, exp2)
; (scan&parse ">(1, 2)")
; -menor-igual: Es una expresion que determina si un numero es menor o igual que otro, tiene la forma:
; <=(exp1, exp2)
; (scan&parse "<=(1, 2)")
; -mayor-igual: Es una expresion que determina si un numero es mayor o igual que otro, tiene la forma:
; >=(exp1, exp2)
; (scan&parse ">=(1, 2)")
; -equivalente: Es una expresion que determina si un numero es igual que otro, tiene la forma:
; ==(exp1, exp2)
; (scan&parse "==(1, 2)")
; -diferente: Es una expresion que determina si un numero es diferente a otro, tiene la forma:
; <>(exp1, exp2)
; (scan&parse "<>(1, 2)")
; OPERACIONES BINARIAS: son representadas por exp-bool-bin
; -conjuncion: Es una expresion que evalua dos expresiones booleanas y retorna true si ambas son
; verdaderas, en cualquier otro caso retorna false, tiene la forma: and(exp-bool1, exp-bool2)
; (scan&parse "and(true, false)")
; -disyuncion: Es una expresion que evalua dos expresiones booleanas y retorna true si al menos una
; es verdadera, si ambas son falsas, retorna false. Tiene la forma: or(exp-bool1, exp-bool2)
; (scan&parse "or(true, false)")
; OPERACION UNARIA: es representada por exp-bool-un
; -negacion: Es una expresion que retorna la negacion de una expresion booleana, tiene la forma:
; not(exp-bool)
; (scan&parse "not(false)")
; BOOLEANOS BASE: son representados por booleano-simple
; -bool-false: Es una expresion que representa un false, tiene la forma: false
; (scan&parse "false")
; -bool-true: Es una expresion que representa un true, tiene la forma: true
; (scan&parse "true")
; --------------------------------------------------------------------------------------------------
; ESTRUCTURAS DE CONTROL:
; begin-exp: Permite ejecutar expresiones secuencialmente. Tiene la forma: begin(exp1; exp2...) end
; (scan&parse "begin{if ==(x,1) then 1 [else 2] end ; x} end")
; if-exp: es una estructura de control que permite evaluar si una condicion es verdadera o falsa.
; Tiene la forma: if bool-exp1 then exp1 [else exp2] end
; (scan&parse "if ==(x,1) then 1 [else 2] end")
; while-exp:es una estructura de repeticion while que se ejecuta hasta que la condiccion sea falsa
; o verdadera.
; Tiene la forma: while bool-exp1 do (exp1) end
; (scan&parse "while >(x,1) do (if ==(x,1) then 1 [else 2] end)done")
; for-exp:es una estructura de repeticion for que se ejecuta una expresion cierto numero de veces,
; emplea una primitiva que indica si el contador debe aumentar o disminuir, las primitivas son: to,
; downto.
; Tiene la forma: for id1 = exp1 prim exp2 do (exp3) done
; (scan&parse " for x = 1 to 3 do( y )done")
; -------------------------------------------------------------------------------------------------------
; VARIABLES MUTABLES:
; set-exp: Es una expresion que representa el cambio de valor en una variable mutable, tiene la forma:
; set id1 -> exp1
; (scan&parse "set x -> 20")
; -------------------------------------------------------------------------------------------------------
; ITERACION:
; print-exp: Es una expresion que representa una salida en pantalla de una expresion, tiene la forma:
; print(exp1)
; (scan&parse "print(+(2,2))")
; -------------------------------------------------------------------------------------------------------
; SOPORTE PARA INSTANCIAS SAT:
; -FNC-exp: Es una expresion que representa un problema de satisfaccion booleana, tiene la forma:
; FNC num1 (clausula1 and clausula2...)
; (scan&parse "FNC 2 ((1 or 2)and (-2))")
; -or-clause: Es una expresion que representa una calsula or usada en las FNC-exp, tiene al forma:
; (num1 or num2...)
; No es una expression, no se puede mostrar mediante scan&parse.
; ---------------------------------------------------------------------------------------------------
; PROCEDIMIENTOS
; proc-exp: es una expresion que respresenta un procedimiento el cual retorna un valor al ser invocado
; (scan&parse "proc (x y) {if >(x,2) then 0 [else 1] end}")
; procrec-exp: es una expresion que respresenta un procedimiento el cual puede ser invocado de manera recursiva
; (scan&parse "procrec  (suma(x)= if >(x,2) then proc (suma y) {sub1(1)} [else 0] end) in [suma , 1]")
; proc-prim: Permite es paso de la estructura por valor
; (scan&parse "[x , y]")
; proc-prim: Permite es paso de la estructura por referencia con la distincion &
; (scan&parse "[x , &y]")
